"""
Source-level debugging functionality for W65C02S emulator.

This module provides source-level debugging capabilities including:
- .rpt assembler report parsing
- .lmap linker map parsing  
- Address to source line mapping
- Symbol name resolution
- Source code display functionality
"""

from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, field
from enum import Enum, auto
import re
import os
from pathlib import Path


class SourceFileType(Enum):
    """Types of source files supported."""
    ASSEMBLY = auto()       # .asm, .s files
    C_SOURCE = auto()       # .c files
    HEADER = auto()         # .h, .inc files
    LISTING = auto()        # .lst files
    UNKNOWN = auto()


@dataclass
class SourceLine:
    """Represents a single line of source code."""
    file_path: str
    line_number: int
    content: str
    address: Optional[int] = None
    bytes_generated: Optional[List[int]] = None
    label: Optional[str] = None
    instruction: Optional[str] = None
    comment: Optional[str] = None


@dataclass
class SourceFile:
    """Represents a complete source file."""
    file_path: str
    file_type: SourceFileType
    lines: List[SourceLine] = field(default_factory=list)
    symbols: Dict[str, int] = field(default_factory=dict)  # symbol -> address
    includes: List[str] = field(default_factory=list)
    
    def get_line(self, line_number: int) -> Optional[SourceLine]:
        """Get a specific line by number."""
        for line in self.lines:
            if line.line_number == line_number:
                return line
        return None
    
    def get_lines_for_address(self, address: int) -> List[SourceLine]:
        """Get all lines that generate code at the given address."""
        return [line for line in self.lines if line.address == address]


@dataclass
class Symbol:
    """Represents a symbol (label, variable, function)."""
    name: str
    address: int
    symbol_type: str = "label"  # label, variable, function, etc.
    size: Optional[int] = None
    source_file: Optional[str] = None
    source_line: Optional[int] = None
    scope: str = "global"  # global, local, external


class ReportParser:
    """Parses assembler report (.rpt) files."""
    
    def __init__(self):
        self._current_file = ""
        self._line_patterns = {
            'file_directive': re.compile(r'^\s*;\s*file:\s*(.+)$', re.IGNORECASE),
            'listing_line': re.compile(r'^(\d+)\s+([0-9A-Fa-f]{4})\s+([0-9A-Fa-f\s]*)\s+(.*)$'),
            'symbol_line': re.compile(r'^(\w+)\s*=\s*\$([0-9A-Fa-f]+)'),
            'include_line': re.compile(r'^\s*include\s+["\']([^"\']+)["\']', re.IGNORECASE)
        }
    
    def parse_report(self, report_content: str) -> Dict[str, SourceFile]:
        """
        Parse assembler report content.
        
        Args:
            report_content: Content of the .rpt file
            
        Returns:
            Dictionary mapping file paths to SourceFile objects
        """
        files = {}
        current_file = None
        
        lines = report_content.split('\n')
        
        for line_text in lines:
            line_text = line_text.rstrip()
            
            # Check for file directive
            file_match = self._line_patterns['file_directive'].match(line_text)
            if file_match:
                file_path = file_match.group(1).strip()
                if file_path not in files:
                    files[file_path] = SourceFile(
                        file_path=file_path,
                        file_type=self._detect_file_type(file_path)
                    )
                current_file = files[file_path]
                continue
            
            if current_file is None:
                continue
            
            # Check for listing line (line with address and bytes)
            listing_match = self._line_patterns['listing_line'].match(line_text)
            if listing_match:
                line_number = int(listing_match.group(1))
                address = int(listing_match.group(2), 16)
                bytes_str = listing_match.group(3).strip()
                source_content = listing_match.group(4)
                
                # Parse generated bytes
                bytes_generated = []
                if bytes_str:
                    byte_parts = bytes_str.split()
                    for byte_part in byte_parts:
                        if len(byte_part) == 2:
                            try:
                                bytes_generated.append(int(byte_part, 16))
                            except ValueError:
                                pass
                
                # Parse source content for label, instruction, comment
                label, instruction, comment = self._parse_source_content(source_content)
                
                source_line = SourceLine(
                    file_path=current_file.file_path,
                    line_number=line_number,
                    content=source_content,
                    address=address,
                    bytes_generated=bytes_generated if bytes_generated else None,
                    label=label,
                    instruction=instruction,
                    comment=comment
                )
                
                current_file.lines.append(source_line)
                
                # Add label to symbols if present
                if label:
                    current_file.symbols[label] = address
                
                continue
            
            # Check for symbol definition
            symbol_match = self._line_patterns['symbol_line'].match(line_text)
            if symbol_match and current_file:
                symbol_name = symbol_match.group(1)
                symbol_address = int(symbol_match.group(2), 16)
                current_file.symbols[symbol_name] = symbol_address
                continue
            
            # Check for include directive
            include_match = self._line_patterns['include_line'].match(line_text)
            if include_match and current_file:
                include_file = include_match.group(1)
                current_file.includes.append(include_file)
                continue
        
        return files
    
    def _detect_file_type(self, file_path: str) -> SourceFileType:
        """Detect file type from extension."""
        ext = Path(file_path).suffix.lower()
        
        if ext in ['.asm', '.s']:
            return SourceFileType.ASSEMBLY
        elif ext == '.c':
            return SourceFileType.C_SOURCE
        elif ext in ['.h', '.inc']:
            return SourceFileType.HEADER
        elif ext == '.lst':
            return SourceFileType.LISTING
        else:
            return SourceFileType.UNKNOWN
    
    def _parse_source_content(self, content: str) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """Parse source content into label, instruction, and comment."""
        content = content.strip()
        if not content:
            return None, None, None
        
        label = None
        instruction = None
        comment = None
        
        # Check for comment
        comment_pos = content.find(';')
        if comment_pos >= 0:
            comment = content[comment_pos + 1:].strip()
            content = content[:comment_pos].strip()
        
        if not content:
            return label, instruction, comment
        
        # Check for label (ends with colon)
        if ':' in content:
            parts = content.split(':', 1)
            if len(parts) == 2:
                label = parts[0].strip()
                instruction = parts[1].strip() if parts[1].strip() else None
            else:
                instruction = content
        else:
            instruction = content
        
        return label, instruction, comment


class MapParser:
    """Parses linker map (.lmap) files."""
    
    def __init__(self):
        self._section_patterns = {
            'symbol_table': re.compile(r'^\s*Symbol\s+Table', re.IGNORECASE),
            'memory_map': re.compile(r'^\s*Memory\s+Map', re.IGNORECASE),
            'symbol_entry': re.compile(r'^(\w+)\s+([0-9A-Fa-f]{4})\s+(\w+)(?:\s+(\w+))?(?:\s+(.+))?$')
        }
    
    def parse_map(self, map_content: str) -> Dict[str, Symbol]:
        """
        Parse linker map content.
        
        Args:
            map_content: Content of the .lmap file
            
        Returns:
            Dictionary mapping symbol names to Symbol objects
        """
        symbols = {}
        lines = map_content.split('\n')
        
        in_symbol_table = False
        
        for line in lines:
            line = line.strip()
            
            # Check for symbol table section
            if self._section_patterns['symbol_table'].match(line):
                in_symbol_table = True
                continue
            
            # Check for end of symbol table (next section)
            if in_symbol_table and self._section_patterns['memory_map'].match(line):
                in_symbol_table = False
                continue
            
            # Parse symbol entries
            if in_symbol_table:
                symbol_match = self._section_patterns['symbol_entry'].match(line)
                if symbol_match:
                    name = symbol_match.group(1)
                    address = int(symbol_match.group(2), 16)
                    symbol_type = symbol_match.group(3).lower()
                    scope = symbol_match.group(4) if symbol_match.group(4) else "global"
                    source_info = symbol_match.group(5) if symbol_match.group(5) else None
                    
                    # Parse source info if available (format: file:line)
                    source_file = None
                    source_line = None
                    if source_info and ':' in source_info:
                        parts = source_info.split(':')
                        if len(parts) >= 2:
                            source_file = parts[0]
                            try:
                                source_line = int(parts[1])
                            except ValueError:
                                pass
                    
                    symbol = Symbol(
                        name=name,
                        address=address,
                        symbol_type=symbol_type,
                        scope=scope,
                        source_file=source_file,
                        source_line=source_line
                    )
                    
                    symbols[name] = symbol
        
        return symbols


class SymbolManager:
    """Manages symbols from multiple sources."""
    
    def __init__(self):
        self._symbols: Dict[str, Symbol] = {}
        self._address_to_symbols: Dict[int, List[str]] = {}
    
    def add_symbol(self, symbol: Symbol) -> None:
        """Add a symbol."""
        self._symbols[symbol.name] = symbol
        
        # Update address mapping
        if symbol.address not in self._address_to_symbols:
            self._address_to_symbols[symbol.address] = []
        self._address_to_symbols[symbol.address].append(symbol.name)
    
    def add_symbols_from_dict(self, symbols: Dict[str, int], symbol_type: str = "label") -> None:
        """Add symbols from a dictionary."""
        for name, address in symbols.items():
            symbol = Symbol(name=name, address=address, symbol_type=symbol_type)
            self.add_symbol(symbol)
    
    def get_symbol(self, name: str) -> Optional[Symbol]:
        """Get symbol by name."""
        return self._symbols.get(name)
    
    def get_symbols_at_address(self, address: int) -> List[Symbol]:
        """Get all symbols at a specific address."""
        symbol_names = self._address_to_symbols.get(address, [])
        return [self._symbols[name] for name in symbol_names if name in self._symbols]
    
    def find_nearest_symbol(self, address: int) -> Optional[Tuple[Symbol, int]]:
        """Find the nearest symbol before or at the given address."""
        best_symbol = None
        best_distance = float('inf')
        
        for symbol in self._symbols.values():
            if symbol.address <= address:
                distance = address - symbol.address
                if distance < best_distance:
                    best_distance = distance
                    best_symbol = symbol
        
        return (best_symbol, int(best_distance)) if best_symbol else None
    
    def get_all_symbols(self) -> Dict[str, Symbol]:
        """Get all symbols."""
        return self._symbols.copy()
    
    def clear(self) -> None:
        """Clear all symbols."""
        self._symbols.clear()
        self._address_to_symbols.clear()


class SourceDebugger:
    """
    Main source-level debugging interface.
    
    Provides functionality for mapping between addresses and source code,
    symbol resolution, and source code display.
    """
    
    def __init__(self):
        self._source_files: Dict[str, SourceFile] = {}
        self._symbol_manager = SymbolManager()
        self._address_to_source: Dict[int, List[Tuple[str, int]]] = {}  # address -> [(file, line)]
        self._report_parser = ReportParser()
        self._map_parser = MapParser()
    
    def load_report_file(self, report_path: str) -> int:
        """
        Load assembler report file.
        
        Args:
            report_path: Path to .rpt file
            
        Returns:
            Number of source files loaded
        """
        try:
            with open(report_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except UnicodeDecodeError:
            # Try with different encoding
            with open(report_path, 'r', encoding='latin-1') as f:
                content = f.read()
        
        files = self._report_parser.parse_report(content)
        
        for file_path, source_file in files.items():
            self._source_files[file_path] = source_file
            
            # Add symbols to symbol manager
            self._symbol_manager.add_symbols_from_dict(source_file.symbols)
            
            # Build address to source mapping
            for line in source_file.lines:
                if line.address is not None:
                    if line.address not in self._address_to_source:
                        self._address_to_source[line.address] = []
                    self._address_to_source[line.address].append((file_path, line.line_number))
        
        return len(files)
    
    def load_map_file(self, map_path: str) -> int:
        """
        Load linker map file.
        
        Args:
            map_path: Path to .lmap file
            
        Returns:
            Number of symbols loaded
        """
        with open(map_path, 'r') as f:
            content = f.read()
        
        symbols = self._map_parser.parse_map(content)
        
        for symbol in symbols.values():
            self._symbol_manager.add_symbol(symbol)
        
        return len(symbols)
    
    def get_source_location(self, address: int) -> Optional[Tuple[str, int, SourceLine]]:
        """
        Get source location for an address.
        
        Args:
            address: Memory address
            
        Returns:
            Tuple of (file_path, line_number, SourceLine) or None
        """
        if address not in self._address_to_source:
            return None
        
        # Get the first source location for this address
        file_path, line_number = self._address_to_source[address][0]
        
        if file_path in self._source_files:
            source_file = self._source_files[file_path]
            source_line = source_file.get_line(line_number)
            if source_line:
                return (file_path, line_number, source_line)
        
        return None
    
    def get_address_for_source(self, file_path: str, line_number: int) -> Optional[int]:
        """
        Get address for a source location.
        
        Args:
            file_path: Source file path
            line_number: Line number
            
        Returns:
            Address or None if not found
        """
        if file_path in self._source_files:
            source_file = self._source_files[file_path]
            source_line = source_file.get_line(line_number)
            if source_line:
                return source_line.address
        
        return None
    
    def resolve_symbol(self, symbol_name: str) -> Optional[Symbol]:
        """Resolve symbol name to Symbol object."""
        return self._symbol_manager.get_symbol(symbol_name)
    
    def get_symbol_at_address(self, address: int) -> Optional[str]:
        """Get primary symbol name at address."""
        symbols = self._symbol_manager.get_symbols_at_address(address)
        return symbols[0].name if symbols else None
    
    def find_nearest_symbol(self, address: int) -> Optional[Tuple[str, int]]:
        """Find nearest symbol and distance."""
        result = self._symbol_manager.find_nearest_symbol(address)
        return (result[0].name, result[1]) if result else None
    
    def show_source_context(self, address: int, context_lines: int = 5) -> List[str]:
        """
        Show source code context around an address.
        
        Args:
            address: Memory address
            context_lines: Number of lines before/after to show
            
        Returns:
            List of formatted source lines
        """
        location = self.get_source_location(address)
        if not location:
            return [f"No source information available for address 0x{address:04X}"]
        
        file_path, target_line, _ = location
        source_file = self._source_files[file_path]
        
        lines = []
        lines.append(f"Source: {file_path}")
        lines.append("")
        
        # Find the range of lines to display
        start_line = max(1, target_line - context_lines)
        end_line = target_line + context_lines
        
        for line in source_file.lines:
            if start_line <= line.line_number <= end_line:
                marker = ">>>" if line.line_number == target_line else "   "
                addr_str = f"0x{line.address:04X}" if line.address is not None else "    "
                
                formatted_line = f"{marker} {line.line_number:4d} {addr_str}  {line.content}"
                lines.append(formatted_line)
        
        return lines
    
    def list_source_files(self) -> List[str]:
        """Get list of loaded source files."""
        return list(self._source_files.keys())
    
    def get_source_file_info(self, file_path: str) -> Optional[Dict[str, Any]]:
        """Get information about a source file."""
        if file_path not in self._source_files:
            return None
        
        source_file = self._source_files[file_path]
        
        return {
            'file_path': source_file.file_path,
            'file_type': source_file.file_type.name,
            'line_count': len(source_file.lines),
            'symbol_count': len(source_file.symbols),
            'includes': source_file.includes,
            'address_range': self._get_address_range(source_file)
        }
    
    def _get_address_range(self, source_file: SourceFile) -> Optional[Tuple[int, int]]:
        """Get address range covered by a source file."""
        addresses = [line.address for line in source_file.lines if line.address is not None]
        if not addresses:
            return None
        
        return (min(addresses), max(addresses))
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get source debugging statistics."""
        total_lines = sum(len(sf.lines) for sf in self._source_files.values())
        total_symbols = len(self._symbol_manager.get_all_symbols())
        
        file_types = {}
        for source_file in self._source_files.values():
            file_type = source_file.file_type.name
            file_types[file_type] = file_types.get(file_type, 0) + 1
        
        return {
            'source_files': len(self._source_files),
            'total_source_lines': total_lines,
            'total_symbols': total_symbols,
            'address_mappings': len(self._address_to_source),
            'file_types': file_types
        }
